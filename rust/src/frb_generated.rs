// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -180218191;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__quran__search__fts_search_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fts_search",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_query = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::quran::search::fts_search(api_query))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quiz__quiz_fragment_completion__generate_batch_fragment_quizzes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_batch_fragment_quizzes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filter =
                <crate::data_loader::quiz_models::QuizFilter>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quiz::quiz_fragment_completion::generate_batch_fragment_quizzes(
                            api_filter,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quiz__verse_completion__generate_batch_verse_completion_quizzes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_batch_verse_completion_quizzes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filter =
                <crate::data_loader::quiz_models::QuizFilter>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quiz::verse_completion::generate_batch_verse_completion_quizzes(
                            api_filter,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quiz__verse_order__generate_batch_verse_order_quizzes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_batch_verse_order_quizzes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filter =
                <crate::data_loader::quiz_models::QuizFilter>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quiz::verse_order::generate_batch_verse_order_quizzes(
                            api_filter,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quiz__verse_previous__generate_batch_verse_previous_quizzes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_batch_verse_previous_quizzes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filter =
                <crate::data_loader::quiz_models::QuizFilter>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quiz::verse_previous::generate_batch_verse_previous_quizzes(
                            api_filter,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quiz__verse_previous__generate_previous_verse_quiz_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_previous_verse_quiz",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filter =
                <crate::data_loader::quiz_models::QuizFilter>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quiz::verse_previous::generate_previous_verse_quiz(api_filter),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quiz__verse_completion__generate_verse_completion_quiz_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_verse_completion_quiz",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filter =
                <crate::data_loader::quiz_models::QuizFilter>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::quiz::verse_completion::generate_verse_completion_quiz(api_filter),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__quiz__quiz_fragment_completion__generate_verse_fragment_quiz_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_verse_fragment_quiz",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filter =
                <crate::data_loader::quiz_models::QuizFilter>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::quiz::quiz_fragment_completion::generate_verse_fragment_quiz(
                        api_filter,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__quran__chapter__get_all_chapters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_all_chapters",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::quran::chapter::get_all_chapters())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__metadata__get_all_juzs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_all_juzs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::quran::metadata::get_all_juzs())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__metadata__get_all_juzs_with_page_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_all_juzs_with_page",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::quran::metadata::get_all_juzs_with_page())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__chapter__get_ayahs_by_surah_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_ayahs_by_surah",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_chapter_id = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::chapter::get_ayahs_by_surah(api_chapter_id),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__metadata__get_chapter_by_page_number_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_chapter_by_page_number",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_page_number = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::metadata::get_chapter_by_page_number(api_page_number),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__chapter__get_chapter_details_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_chapter_details",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_chapter_id = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::chapter::get_chapter_details(api_chapter_id),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__chapter__get_chapter_name_simple_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_chapter_name_simple",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_chapter_id = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::chapter::get_chapter_name_simple(api_chapter_id),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__metadata__get_juz_details_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_juz_details",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_juz_number = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::metadata::get_juz_details(api_juz_number),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__verse__get_juz_number_for_verse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_juz_number_for_verse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_verse_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::verse::get_juz_number_for_verse(api_verse_key),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__metadata__get_mushaf_page_context_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_mushaf_page_context_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_page_number = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::quran::metadata::get_mushaf_page_context_info(
                            api_page_number,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__quran__metadata__get_page_from_verse_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_page_from_verse_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_verse_id = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::metadata::get_page_from_verse_id(api_verse_id),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__mushaf__get_page_image_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_page_image",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_page = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::mushaf::get_page_image(api_page))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__mushaf__get_page_metadata_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_page_metadata",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_page = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::mushaf::get_page_metadata(api_page))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__similarity__get_similar_ayahs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_similar_ayahs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_verse_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::similarity::get_similar_ayahs(api_verse_key),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__similarity__get_similar_ayahs_inverted_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_similar_ayahs_inverted",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_verse_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::similarity::get_similar_ayahs_inverted(api_verse_key),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__verse__get_translation_text_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_translation_text",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_verse_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::verse::get_translation_text(&api_verse_key),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__verse__get_verse_by_chapter_and_verse_number_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_verse_by_chapter_and_verse_number",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_chapter_number = <u32>::sse_decode(&mut deserializer);
            let api_verse_number = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::verse::get_verse_by_chapter_and_verse_number(
                            api_chapter_number,
                            api_verse_number,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__verse__get_verse_details_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_verse_details",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_verse_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::verse::get_verse_details(api_verse_key),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__verse__get_verse_text_uthmani_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_verse_text_uthmani",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_verse_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::verse::get_verse_text_uthmani(api_verse_key),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__verse__get_verse_texts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_verse_texts",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_verse_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::verse::get_verse_texts(api_verse_key),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quran__verse__get_word_details_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_word_details",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_verse_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quran::verse::get_word_details(api_verse_key),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__simple__greet_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "greet",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::simple::greet(api_name))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__simple__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::simple::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__quiz__verse_completion__inner_generate_verse_completion_quiz_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "inner_generate_verse_completion_quiz",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filter =
                <crate::data_loader::quiz_models::QuizFilter>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::quiz::verse_completion::inner_generate_verse_completion_quiz(
                            api_filter,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__whisper__is_whisper_model_loaded_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_whisper_model_loaded",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::whisper::is_whisper_model_loaded())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__engine_loader__load_engine_data_from_flutter_assets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_engine_data_from_flutter_assets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_map =
                <std::collections::HashMap<String, Vec<u8>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::engine_loader::load_engine_data_from_flutter_assets(
                                api_map,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__whisper__load_whisper_model_from_flutter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_whisper_model_from_flutter",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::whisper::load_whisper_model_from_flutter(api_data)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__mushaf__open_mushaf_pack_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "open_mushaf_pack",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::mushaf::open_mushaf_pack(api_path)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__engine_loader__reset_engine_from_flutter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reset_engine_from_flutter",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_map =
                <std::collections::HashMap<String, Vec<u8>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::engine_loader::reset_engine_from_flutter(api_map)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, String)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, Vec<u8>)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::data_loader::ayah_texts::AyahText {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_verseKey = <String>::sse_decode(deserializer);
        let mut var_textUthmaniSimple = <String>::sse_decode(deserializer);
        let mut var_textUthmani = <String>::sse_decode(deserializer);
        let mut var_textQpcHafs = <String>::sse_decode(deserializer);
        return crate::data_loader::ayah_texts::AyahText {
            verse_key: var_verseKey,
            text_uthmani_simple: var_textUthmaniSimple,
            text_uthmani: var_textUthmani,
            text_qpc_hafs: var_textQpcHafs,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::data_loader::chapters::Chapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <u32>::sse_decode(deserializer);
        let mut var_revelationPlace = <String>::sse_decode(deserializer);
        let mut var_revelationOrder = <u32>::sse_decode(deserializer);
        let mut var_bismillahPre = <bool>::sse_decode(deserializer);
        let mut var_nameSimple = <String>::sse_decode(deserializer);
        let mut var_nameComplex = <String>::sse_decode(deserializer);
        let mut var_nameArabic = <String>::sse_decode(deserializer);
        let mut var_versesCount = <u32>::sse_decode(deserializer);
        let mut var_pages = <Vec<u32>>::sse_decode(deserializer);
        let mut var_translatedName =
            <crate::data_loader::chapters::TranslatedName>::sse_decode(deserializer);
        return crate::data_loader::chapters::Chapter {
            id: var_id,
            revelation_place: var_revelationPlace,
            revelation_order: var_revelationOrder,
            bismillah_pre: var_bismillahPre,
            name_simple: var_nameSimple,
            name_complex: var_nameComplex,
            name_arabic: var_nameArabic,
            verses_count: var_versesCount,
            pages: var_pages,
            translated_name: var_translatedName,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::GlyphPosition {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_glyphId = <u32>::sse_decode(deserializer);
        let mut var_pageNumber = <u16>::sse_decode(deserializer);
        let mut var_lineNumber = <u8>::sse_decode(deserializer);
        let mut var_sura = <u16>::sse_decode(deserializer);
        let mut var_ayah = <u16>::sse_decode(deserializer);
        let mut var_wordPosition = <u16>::sse_decode(deserializer);
        let mut var_minX = <u32>::sse_decode(deserializer);
        let mut var_maxX = <u32>::sse_decode(deserializer);
        let mut var_minY = <u32>::sse_decode(deserializer);
        let mut var_maxY = <u32>::sse_decode(deserializer);
        return crate::models::GlyphPosition {
            glyph_id: var_glyphId,
            page_number: var_pageNumber,
            line_number: var_lineNumber,
            sura: var_sura,
            ayah: var_ayah,
            word_position: var_wordPosition,
            min_x: var_minX,
            max_x: var_maxX,
            min_y: var_minY,
            max_y: var_maxY,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::data_loader::juzs::Juz {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <u32>::sse_decode(deserializer);
        let mut var_juzNumber = <u32>::sse_decode(deserializer);
        let mut var_verseMapping =
            <std::collections::HashMap<String, String>>::sse_decode(deserializer);
        let mut var_firstVerseId = <u32>::sse_decode(deserializer);
        let mut var_lastVerseId = <u32>::sse_decode(deserializer);
        let mut var_versesCount = <u32>::sse_decode(deserializer);
        return crate::data_loader::juzs::Juz {
            id: var_id,
            juz_number: var_juzNumber,
            verse_mapping: var_verseMapping,
            first_verse_id: var_firstVerseId,
            last_verse_id: var_lastVerseId,
            verses_count: var_versesCount,
        };
    }
}

impl SseDecode for crate::data_loader::juzs::JuzWithPage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_juz = <crate::data_loader::juzs::Juz>::sse_decode(deserializer);
        let mut var_pageNumber = <u32>::sse_decode(deserializer);
        return crate::data_loader::juzs::JuzWithPage {
            juz: var_juz,
            page_number: var_pageNumber,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::data_loader::ayah_texts::AyahText> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::data_loader::ayah_texts::AyahText>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::data_loader::chapters::Chapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::data_loader::chapters::Chapter>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::GlyphPosition> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::GlyphPosition>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::data_loader::juzs::Juz> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::data_loader::juzs::Juz>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::data_loader::juzs::JuzWithPage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::data_loader::juzs::JuzWithPage>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<u32>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<u32>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::data_loader::valid_matching_ayah::MatchedAyah> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::data_loader::valid_matching_ayah::MatchedAyah>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u32>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::data_loader::quiz_models::QuizOption> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::data_loader::quiz_models::QuizOption>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::data_loader::quiz_models::QuizQuestion> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::data_loader::quiz_models::QuizQuestion>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, Vec<u8>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, Vec<u8>)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::data_loader::search_models::SearchResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::data_loader::search_models::SearchResult>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::data_loader::verse_by_chapter::TajweedSegment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::data_loader::verse_by_chapter::TajweedSegment>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::data_loader::verse_by_chapter::Translation> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::data_loader::verse_by_chapter::Translation>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::data_loader::verse_by_chapter::Word> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::data_loader::verse_by_chapter::Word>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::data_loader::search_models::WordResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::data_loader::search_models::WordResult>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for crate::data_loader::valid_matching_ayah::MatchedAyah {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_matchedAyahKey = <String>::sse_decode(deserializer);
        let mut var_matchedWordsCount = <u32>::sse_decode(deserializer);
        let mut var_coverage = <u32>::sse_decode(deserializer);
        let mut var_score = <u32>::sse_decode(deserializer);
        let mut var_matchWords = <Vec<Vec<u32>>>::sse_decode(deserializer);
        return crate::data_loader::valid_matching_ayah::MatchedAyah {
            matched_ayah_key: var_matchedAyahKey,
            matched_words_count: var_matchedWordsCount,
            coverage: var_coverage,
            score: var_score,
            match_words: var_matchWords,
        };
    }
}

impl SseDecode for crate::data_loader::mushaf_page_info::MushafPageInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_surahNameArabic = <String>::sse_decode(deserializer);
        let mut var_juzNumber = <u32>::sse_decode(deserializer);
        let mut var_pageNumber = <u32>::sse_decode(deserializer);
        let mut var_nextPageRouteText = <String>::sse_decode(deserializer);
        return crate::data_loader::mushaf_page_info::MushafPageInfo {
            surah_name_arabic: var_surahNameArabic,
            juz_number: var_juzNumber,
            page_number: var_pageNumber,
            next_page_route_text: var_nextPageRouteText,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::data_loader::chapters::Chapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::data_loader::chapters::Chapter>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::data_loader::juzs::Juz> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::data_loader::juzs::Juz>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::data_loader::quiz_models::QuizGenerationError> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::data_loader::quiz_models::QuizGenerationError>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::data_loader::quiz_models::QuizQuestion> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::data_loader::quiz_models::QuizQuestion>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::data_loader::verse_by_chapter::Translation> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::data_loader::verse_by_chapter::Translation>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::data_loader::verse_by_chapter::Verse> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::data_loader::verse_by_chapter::Verse>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::data_loader::verse_by_chapter::VerseDetailWithWords> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::data_loader::verse_by_chapter::VerseDetailWithWords>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<String>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::GlyphPosition>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::GlyphPosition>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<u32>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<u32>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<u8>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::data_loader::quiz_models::QuizFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_scope = <crate::data_loader::quiz_models::QuizScope>::sse_decode(deserializer);
        let mut var_quizCount = <u32>::sse_decode(deserializer);
        return crate::data_loader::quiz_models::QuizFilter {
            scope: var_scope,
            quiz_count: var_quizCount,
        };
    }
}

impl SseDecode for crate::data_loader::quiz_models::QuizGenerationError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::data_loader::quiz_models::QuizGenerationError::InternalError(
                    var_field0,
                );
            }
            1 => {
                return crate::data_loader::quiz_models::QuizGenerationError::NoVersesInScope;
            }
            2 => {
                return crate::data_loader::quiz_models::QuizGenerationError::NoValidQuestionFound;
            }
            3 => {
                return crate::data_loader::quiz_models::QuizGenerationError::MissingAyahText;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::data_loader::quiz_models::QuizGenerationResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_question =
            <Option<crate::data_loader::quiz_models::QuizQuestion>>::sse_decode(deserializer);
        let mut var_error =
            <Option<crate::data_loader::quiz_models::QuizGenerationError>>::sse_decode(
                deserializer,
            );
        return crate::data_loader::quiz_models::QuizGenerationResult {
            question: var_question,
            error: var_error,
        };
    }
}

impl SseDecode for crate::data_loader::quiz_models::QuizOption {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_text = <String>::sse_decode(deserializer);
        let mut var_isCorrect = <bool>::sse_decode(deserializer);
        return crate::data_loader::quiz_models::QuizOption {
            text: var_text,
            is_correct: var_isCorrect,
        };
    }
}

impl SseDecode for crate::data_loader::quiz_models::QuizQuestion {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_verseKey = <String>::sse_decode(deserializer);
        let mut var_questionTextPart1 = <String>::sse_decode(deserializer);
        let mut var_questionTextPart2 = <String>::sse_decode(deserializer);
        let mut var_missingPartText = <String>::sse_decode(deserializer);
        let mut var_options =
            <Vec<crate::data_loader::quiz_models::QuizOption>>::sse_decode(deserializer);
        let mut var_correctAnswerIndex = <u32>::sse_decode(deserializer);
        let mut var_correctOrderIndices = <Option<Vec<u32>>>::sse_decode(deserializer);
        let mut var_quizType = <String>::sse_decode(deserializer);
        let mut var_shuffledParts = <Option<Vec<String>>>::sse_decode(deserializer);
        let mut var_shuffledKeys = <Option<Vec<String>>>::sse_decode(deserializer);
        let mut var_correctOrderKeys = <Option<Vec<String>>>::sse_decode(deserializer);
        return crate::data_loader::quiz_models::QuizQuestion {
            verse_key: var_verseKey,
            question_text_part1: var_questionTextPart1,
            question_text_part2: var_questionTextPart2,
            missing_part_text: var_missingPartText,
            options: var_options,
            correct_answer_index: var_correctAnswerIndex,
            correct_order_indices: var_correctOrderIndices,
            quiz_type: var_quizType,
            shuffled_parts: var_shuffledParts,
            shuffled_keys: var_shuffledKeys,
            correct_order_keys: var_correctOrderKeys,
        };
    }
}

impl SseDecode for crate::data_loader::quiz_models::QuizQuestions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_questions =
            <Vec<crate::data_loader::quiz_models::QuizQuestion>>::sse_decode(deserializer);
        return crate::data_loader::quiz_models::QuizQuestions {
            questions: var_questions,
        };
    }
}

impl SseDecode for crate::data_loader::quiz_models::QuizScope {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::data_loader::quiz_models::QuizScope::All;
            }
            1 => {
                let mut var_juzNumbers = <Vec<u32>>::sse_decode(deserializer);
                return crate::data_loader::quiz_models::QuizScope::ByJuz {
                    juz_numbers: var_juzNumbers,
                };
            }
            2 => {
                let mut var_surahId = <u32>::sse_decode(deserializer);
                return crate::data_loader::quiz_models::QuizScope::BySurah {
                    surah_id: var_surahId,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for (String, Vec<u8>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <Vec<u8>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::data_loader::search_models::SearchResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_verseKey = <String>::sse_decode(deserializer);
        let mut var_score = <f32>::sse_decode(deserializer);
        let mut var_words =
            <Vec<crate::data_loader::search_models::WordResult>>::sse_decode(deserializer);
        return crate::data_loader::search_models::SearchResult {
            verse_key: var_verseKey,
            score: var_score,
            words: var_words,
        };
    }
}

impl SseDecode for crate::data_loader::verse_by_chapter::TajweedSegment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_rule = <String>::sse_decode(deserializer);
        let mut var_text = <String>::sse_decode(deserializer);
        return crate::data_loader::verse_by_chapter::TajweedSegment {
            rule: var_rule,
            text: var_text,
        };
    }
}

impl SseDecode for crate::data_loader::chapters::TranslatedName {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_languageName = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        return crate::data_loader::chapters::TranslatedName {
            language_name: var_languageName,
            name: var_name,
        };
    }
}

impl SseDecode for crate::data_loader::verse_by_chapter::Translation {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_text = <String>::sse_decode(deserializer);
        let mut var_footnotes =
            <std::collections::HashMap<String, String>>::sse_decode(deserializer);
        return crate::data_loader::verse_by_chapter::Translation {
            text: var_text,
            footnotes: var_footnotes,
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::data_loader::verse_by_chapter::Verse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <u32>::sse_decode(deserializer);
        let mut var_verseNumber = <u32>::sse_decode(deserializer);
        let mut var_verseKey = <String>::sse_decode(deserializer);
        let mut var_hizbNumber = <u32>::sse_decode(deserializer);
        let mut var_rubElHizbNumber = <u32>::sse_decode(deserializer);
        let mut var_rukuNumber = <u32>::sse_decode(deserializer);
        let mut var_manzilNumber = <u32>::sse_decode(deserializer);
        let mut var_sajdahNumber = <Option<u32>>::sse_decode(deserializer);
        let mut var_pageNumber = <u32>::sse_decode(deserializer);
        let mut var_juzNumber = <u32>::sse_decode(deserializer);
        let mut var_wordIds = <Vec<String>>::sse_decode(deserializer);
        let mut var_translations =
            <Vec<crate::data_loader::verse_by_chapter::Translation>>::sse_decode(deserializer);
        return crate::data_loader::verse_by_chapter::Verse {
            id: var_id,
            verse_number: var_verseNumber,
            verse_key: var_verseKey,
            hizb_number: var_hizbNumber,
            rub_el_hizb_number: var_rubElHizbNumber,
            ruku_number: var_rukuNumber,
            manzil_number: var_manzilNumber,
            sajdah_number: var_sajdahNumber,
            page_number: var_pageNumber,
            juz_number: var_juzNumber,
            word_ids: var_wordIds,
            translations: var_translations,
        };
    }
}

impl SseDecode for crate::data_loader::verse_by_chapter::VerseDetailWithWords {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_verse = <crate::data_loader::verse_by_chapter::Verse>::sse_decode(deserializer);
        let mut var_words =
            <Vec<crate::data_loader::verse_by_chapter::Word>>::sse_decode(deserializer);
        return crate::data_loader::verse_by_chapter::VerseDetailWithWords {
            verse: var_verse,
            words: var_words,
        };
    }
}

impl SseDecode for crate::data_loader::verse_by_chapter::Word {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <u32>::sse_decode(deserializer);
        let mut var_wordKey = <String>::sse_decode(deserializer);
        let mut var_position = <u32>::sse_decode(deserializer);
        let mut var_charTypeName = <String>::sse_decode(deserializer);
        let mut var_textUthmani = <String>::sse_decode(deserializer);
        let mut var_textUthmaniSimple = <String>::sse_decode(deserializer);
        let mut var_textTajweed =
            <Vec<crate::data_loader::verse_by_chapter::TajweedSegment>>::sse_decode(deserializer);
        let mut var_pageNumber = <u32>::sse_decode(deserializer);
        let mut var_lineNumber = <u32>::sse_decode(deserializer);
        let mut var_chapterId = <u32>::sse_decode(deserializer);
        let mut var_verseId = <u32>::sse_decode(deserializer);
        return crate::data_loader::verse_by_chapter::Word {
            id: var_id,
            word_key: var_wordKey,
            position: var_position,
            char_type_name: var_charTypeName,
            text_uthmani: var_textUthmani,
            text_uthmani_simple: var_textUthmaniSimple,
            text_tajweed: var_textTajweed,
            page_number: var_pageNumber,
            line_number: var_lineNumber,
            chapter_id: var_chapterId,
            verse_id: var_verseId,
        };
    }
}

impl SseDecode for crate::data_loader::search_models::WordResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <u32>::sse_decode(deserializer);
        let mut var_position = <u32>::sse_decode(deserializer);
        let mut var_textUthmani = <String>::sse_decode(deserializer);
        let mut var_highlighted = <bool>::sse_decode(deserializer);
        return crate::data_loader::search_models::WordResult {
            id: var_id,
            position: var_position,
            text_uthmani: var_textUthmani,
            highlighted: var_highlighted,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__quran__search__fts_search_impl(port, ptr, rust_vec_len, data_len),
        2 => {
            wire__crate__api__quiz__quiz_fragment_completion__generate_batch_fragment_quizzes_impl(
                port,
                ptr,
                rust_vec_len,
                data_len,
            )
        }
        3 => {
            wire__crate__api__quiz__verse_completion__generate_batch_verse_completion_quizzes_impl(
                port,
                ptr,
                rust_vec_len,
                data_len,
            )
        }
        4 => wire__crate__api__quiz__verse_order__generate_batch_verse_order_quizzes_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        5 => wire__crate__api__quiz__verse_previous__generate_batch_verse_previous_quizzes_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        6 => wire__crate__api__quiz__verse_previous__generate_previous_verse_quiz_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        9 => wire__crate__api__quran__chapter__get_all_chapters_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        10 => {
            wire__crate__api__quran__metadata__get_all_juzs_impl(port, ptr, rust_vec_len, data_len)
        }
        11 => wire__crate__api__quran__metadata__get_all_juzs_with_page_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        12 => wire__crate__api__quran__chapter__get_ayahs_by_surah_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        13 => wire__crate__api__quran__metadata__get_chapter_by_page_number_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        14 => wire__crate__api__quran__chapter__get_chapter_details_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        15 => wire__crate__api__quran__chapter__get_chapter_name_simple_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        16 => wire__crate__api__quran__metadata__get_juz_details_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        17 => wire__crate__api__quran__verse__get_juz_number_for_verse_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        18 => wire__crate__api__quran__metadata__get_mushaf_page_context_info_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        19 => wire__crate__api__quran__metadata__get_page_from_verse_id_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        20 => wire__crate__api__mushaf__get_page_image_impl(port, ptr, rust_vec_len, data_len),
        21 => wire__crate__api__mushaf__get_page_metadata_impl(port, ptr, rust_vec_len, data_len),
        22 => wire__crate__api__quran__similarity__get_similar_ayahs_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        23 => wire__crate__api__quran__similarity__get_similar_ayahs_inverted_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        24 => wire__crate__api__quran__verse__get_translation_text_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        25 => wire__crate__api__quran__verse__get_verse_by_chapter_and_verse_number_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        26 => wire__crate__api__quran__verse__get_verse_details_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        27 => wire__crate__api__quran__verse__get_verse_text_uthmani_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        28 => {
            wire__crate__api__quran__verse__get_verse_texts_impl(port, ptr, rust_vec_len, data_len)
        }
        29 => {
            wire__crate__api__quran__verse__get_word_details_impl(port, ptr, rust_vec_len, data_len)
        }
        31 => wire__crate__api__simple__init_app_impl(port, ptr, rust_vec_len, data_len),
        32 => wire__crate__api__quiz__verse_completion__inner_generate_verse_completion_quiz_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        33 => wire__crate__api__whisper__is_whisper_model_loaded_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        34 => wire__crate__api__engine_loader__load_engine_data_from_flutter_assets_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        35 => wire__crate__api__whisper__load_whisper_model_from_flutter_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        36 => wire__crate__api__mushaf__open_mushaf_pack_impl(port, ptr, rust_vec_len, data_len),
        37 => wire__crate__api__engine_loader__reset_engine_from_flutter_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        7 => wire__crate__api__quiz__verse_completion__generate_verse_completion_quiz_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        8 => wire__crate__api__quiz__quiz_fragment_completion__generate_verse_fragment_quiz_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        30 => wire__crate__api__simple__greet_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::ayah_texts::AyahText {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.verse_key.into_into_dart().into_dart(),
            self.text_uthmani_simple.into_into_dart().into_dart(),
            self.text_uthmani.into_into_dart().into_dart(),
            self.text_qpc_hafs.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::ayah_texts::AyahText
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::ayah_texts::AyahText>
    for crate::data_loader::ayah_texts::AyahText
{
    fn into_into_dart(self) -> crate::data_loader::ayah_texts::AyahText {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::chapters::Chapter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.revelation_place.into_into_dart().into_dart(),
            self.revelation_order.into_into_dart().into_dart(),
            self.bismillah_pre.into_into_dart().into_dart(),
            self.name_simple.into_into_dart().into_dart(),
            self.name_complex.into_into_dart().into_dart(),
            self.name_arabic.into_into_dart().into_dart(),
            self.verses_count.into_into_dart().into_dart(),
            self.pages.into_into_dart().into_dart(),
            self.translated_name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::chapters::Chapter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::chapters::Chapter>
    for crate::data_loader::chapters::Chapter
{
    fn into_into_dart(self) -> crate::data_loader::chapters::Chapter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::GlyphPosition {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.glyph_id.into_into_dart().into_dart(),
            self.page_number.into_into_dart().into_dart(),
            self.line_number.into_into_dart().into_dart(),
            self.sura.into_into_dart().into_dart(),
            self.ayah.into_into_dart().into_dart(),
            self.word_position.into_into_dart().into_dart(),
            self.min_x.into_into_dart().into_dart(),
            self.max_x.into_into_dart().into_dart(),
            self.min_y.into_into_dart().into_dart(),
            self.max_y.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::GlyphPosition {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::GlyphPosition>
    for crate::models::GlyphPosition
{
    fn into_into_dart(self) -> crate::models::GlyphPosition {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::juzs::Juz {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.juz_number.into_into_dart().into_dart(),
            self.verse_mapping.into_into_dart().into_dart(),
            self.first_verse_id.into_into_dart().into_dart(),
            self.last_verse_id.into_into_dart().into_dart(),
            self.verses_count.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::data_loader::juzs::Juz {}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::juzs::Juz>
    for crate::data_loader::juzs::Juz
{
    fn into_into_dart(self) -> crate::data_loader::juzs::Juz {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::juzs::JuzWithPage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.juz.into_into_dart().into_dart(),
            self.page_number.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::juzs::JuzWithPage
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::juzs::JuzWithPage>
    for crate::data_loader::juzs::JuzWithPage
{
    fn into_into_dart(self) -> crate::data_loader::juzs::JuzWithPage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::valid_matching_ayah::MatchedAyah {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.matched_ayah_key.into_into_dart().into_dart(),
            self.matched_words_count.into_into_dart().into_dart(),
            self.coverage.into_into_dart().into_dart(),
            self.score.into_into_dart().into_dart(),
            self.match_words.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::valid_matching_ayah::MatchedAyah
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::valid_matching_ayah::MatchedAyah>
    for crate::data_loader::valid_matching_ayah::MatchedAyah
{
    fn into_into_dart(self) -> crate::data_loader::valid_matching_ayah::MatchedAyah {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::mushaf_page_info::MushafPageInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.surah_name_arabic.into_into_dart().into_dart(),
            self.juz_number.into_into_dart().into_dart(),
            self.page_number.into_into_dart().into_dart(),
            self.next_page_route_text.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::mushaf_page_info::MushafPageInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::mushaf_page_info::MushafPageInfo>
    for crate::data_loader::mushaf_page_info::MushafPageInfo
{
    fn into_into_dart(self) -> crate::data_loader::mushaf_page_info::MushafPageInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::quiz_models::QuizFilter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.scope.into_into_dart().into_dart(),
            self.quiz_count.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::quiz_models::QuizFilter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::quiz_models::QuizFilter>
    for crate::data_loader::quiz_models::QuizFilter
{
    fn into_into_dart(self) -> crate::data_loader::quiz_models::QuizFilter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::quiz_models::QuizGenerationError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::data_loader::quiz_models::QuizGenerationError::InternalError(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::data_loader::quiz_models::QuizGenerationError::NoVersesInScope => {
                [1.into_dart()].into_dart()
            }
            crate::data_loader::quiz_models::QuizGenerationError::NoValidQuestionFound => {
                [2.into_dart()].into_dart()
            }
            crate::data_loader::quiz_models::QuizGenerationError::MissingAyahText => {
                [3.into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::quiz_models::QuizGenerationError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::quiz_models::QuizGenerationError>
    for crate::data_loader::quiz_models::QuizGenerationError
{
    fn into_into_dart(self) -> crate::data_loader::quiz_models::QuizGenerationError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::quiz_models::QuizGenerationResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.question.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::quiz_models::QuizGenerationResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::quiz_models::QuizGenerationResult>
    for crate::data_loader::quiz_models::QuizGenerationResult
{
    fn into_into_dart(self) -> crate::data_loader::quiz_models::QuizGenerationResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::quiz_models::QuizOption {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.text.into_into_dart().into_dart(),
            self.is_correct.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::quiz_models::QuizOption
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::quiz_models::QuizOption>
    for crate::data_loader::quiz_models::QuizOption
{
    fn into_into_dart(self) -> crate::data_loader::quiz_models::QuizOption {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::quiz_models::QuizQuestion {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.verse_key.into_into_dart().into_dart(),
            self.question_text_part1.into_into_dart().into_dart(),
            self.question_text_part2.into_into_dart().into_dart(),
            self.missing_part_text.into_into_dart().into_dart(),
            self.options.into_into_dart().into_dart(),
            self.correct_answer_index.into_into_dart().into_dart(),
            self.correct_order_indices.into_into_dart().into_dart(),
            self.quiz_type.into_into_dart().into_dart(),
            self.shuffled_parts.into_into_dart().into_dart(),
            self.shuffled_keys.into_into_dart().into_dart(),
            self.correct_order_keys.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::quiz_models::QuizQuestion
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::quiz_models::QuizQuestion>
    for crate::data_loader::quiz_models::QuizQuestion
{
    fn into_into_dart(self) -> crate::data_loader::quiz_models::QuizQuestion {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::quiz_models::QuizQuestions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.questions.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::quiz_models::QuizQuestions
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::quiz_models::QuizQuestions>
    for crate::data_loader::quiz_models::QuizQuestions
{
    fn into_into_dart(self) -> crate::data_loader::quiz_models::QuizQuestions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::quiz_models::QuizScope {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::data_loader::quiz_models::QuizScope::All => [0.into_dart()].into_dart(),
            crate::data_loader::quiz_models::QuizScope::ByJuz { juz_numbers } => {
                [1.into_dart(), juz_numbers.into_into_dart().into_dart()].into_dart()
            }
            crate::data_loader::quiz_models::QuizScope::BySurah { surah_id } => {
                [2.into_dart(), surah_id.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::quiz_models::QuizScope
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::quiz_models::QuizScope>
    for crate::data_loader::quiz_models::QuizScope
{
    fn into_into_dart(self) -> crate::data_loader::quiz_models::QuizScope {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::search_models::SearchResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.verse_key.into_into_dart().into_dart(),
            self.score.into_into_dart().into_dart(),
            self.words.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::search_models::SearchResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::search_models::SearchResult>
    for crate::data_loader::search_models::SearchResult
{
    fn into_into_dart(self) -> crate::data_loader::search_models::SearchResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::verse_by_chapter::TajweedSegment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.rule.into_into_dart().into_dart(),
            self.text.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::verse_by_chapter::TajweedSegment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::verse_by_chapter::TajweedSegment>
    for crate::data_loader::verse_by_chapter::TajweedSegment
{
    fn into_into_dart(self) -> crate::data_loader::verse_by_chapter::TajweedSegment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::chapters::TranslatedName {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.language_name.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::chapters::TranslatedName
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::chapters::TranslatedName>
    for crate::data_loader::chapters::TranslatedName
{
    fn into_into_dart(self) -> crate::data_loader::chapters::TranslatedName {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::verse_by_chapter::Translation {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.text.into_into_dart().into_dart(),
            self.footnotes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::verse_by_chapter::Translation
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::verse_by_chapter::Translation>
    for crate::data_loader::verse_by_chapter::Translation
{
    fn into_into_dart(self) -> crate::data_loader::verse_by_chapter::Translation {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::verse_by_chapter::Verse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.verse_number.into_into_dart().into_dart(),
            self.verse_key.into_into_dart().into_dart(),
            self.hizb_number.into_into_dart().into_dart(),
            self.rub_el_hizb_number.into_into_dart().into_dart(),
            self.ruku_number.into_into_dart().into_dart(),
            self.manzil_number.into_into_dart().into_dart(),
            self.sajdah_number.into_into_dart().into_dart(),
            self.page_number.into_into_dart().into_dart(),
            self.juz_number.into_into_dart().into_dart(),
            self.word_ids.into_into_dart().into_dart(),
            self.translations.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::verse_by_chapter::Verse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::verse_by_chapter::Verse>
    for crate::data_loader::verse_by_chapter::Verse
{
    fn into_into_dart(self) -> crate::data_loader::verse_by_chapter::Verse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::verse_by_chapter::VerseDetailWithWords {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.verse.into_into_dart().into_dart(),
            self.words.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::verse_by_chapter::VerseDetailWithWords
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::verse_by_chapter::VerseDetailWithWords>
    for crate::data_loader::verse_by_chapter::VerseDetailWithWords
{
    fn into_into_dart(self) -> crate::data_loader::verse_by_chapter::VerseDetailWithWords {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::verse_by_chapter::Word {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.word_key.into_into_dart().into_dart(),
            self.position.into_into_dart().into_dart(),
            self.char_type_name.into_into_dart().into_dart(),
            self.text_uthmani.into_into_dart().into_dart(),
            self.text_uthmani_simple.into_into_dart().into_dart(),
            self.text_tajweed.into_into_dart().into_dart(),
            self.page_number.into_into_dart().into_dart(),
            self.line_number.into_into_dart().into_dart(),
            self.chapter_id.into_into_dart().into_dart(),
            self.verse_id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::verse_by_chapter::Word
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::verse_by_chapter::Word>
    for crate::data_loader::verse_by_chapter::Word
{
    fn into_into_dart(self) -> crate::data_loader::verse_by_chapter::Word {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::data_loader::search_models::WordResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.position.into_into_dart().into_dart(),
            self.text_uthmani.into_into_dart().into_dart(),
            self.highlighted.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::data_loader::search_models::WordResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::data_loader::search_models::WordResult>
    for crate::data_loader::search_models::WordResult
{
    fn into_into_dart(self) -> crate::data_loader::search_models::WordResult {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, String)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, Vec<u8>)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::data_loader::ayah_texts::AyahText {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.verse_key, serializer);
        <String>::sse_encode(self.text_uthmani_simple, serializer);
        <String>::sse_encode(self.text_uthmani, serializer);
        <String>::sse_encode(self.text_qpc_hafs, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::data_loader::chapters::Chapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.revelation_place, serializer);
        <u32>::sse_encode(self.revelation_order, serializer);
        <bool>::sse_encode(self.bismillah_pre, serializer);
        <String>::sse_encode(self.name_simple, serializer);
        <String>::sse_encode(self.name_complex, serializer);
        <String>::sse_encode(self.name_arabic, serializer);
        <u32>::sse_encode(self.verses_count, serializer);
        <Vec<u32>>::sse_encode(self.pages, serializer);
        <crate::data_loader::chapters::TranslatedName>::sse_encode(
            self.translated_name,
            serializer,
        );
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::GlyphPosition {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.glyph_id, serializer);
        <u16>::sse_encode(self.page_number, serializer);
        <u8>::sse_encode(self.line_number, serializer);
        <u16>::sse_encode(self.sura, serializer);
        <u16>::sse_encode(self.ayah, serializer);
        <u16>::sse_encode(self.word_position, serializer);
        <u32>::sse_encode(self.min_x, serializer);
        <u32>::sse_encode(self.max_x, serializer);
        <u32>::sse_encode(self.min_y, serializer);
        <u32>::sse_encode(self.max_y, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::data_loader::juzs::Juz {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.juz_number, serializer);
        <std::collections::HashMap<String, String>>::sse_encode(self.verse_mapping, serializer);
        <u32>::sse_encode(self.first_verse_id, serializer);
        <u32>::sse_encode(self.last_verse_id, serializer);
        <u32>::sse_encode(self.verses_count, serializer);
    }
}

impl SseEncode for crate::data_loader::juzs::JuzWithPage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::data_loader::juzs::Juz>::sse_encode(self.juz, serializer);
        <u32>::sse_encode(self.page_number, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::data_loader::ayah_texts::AyahText> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::data_loader::ayah_texts::AyahText>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::data_loader::chapters::Chapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::data_loader::chapters::Chapter>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::GlyphPosition> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::GlyphPosition>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::data_loader::juzs::Juz> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::data_loader::juzs::Juz>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::data_loader::juzs::JuzWithPage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::data_loader::juzs::JuzWithPage>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<u32>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<u32>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::data_loader::valid_matching_ayah::MatchedAyah> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::data_loader::valid_matching_ayah::MatchedAyah>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u32>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::data_loader::quiz_models::QuizOption> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::data_loader::quiz_models::QuizOption>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::data_loader::quiz_models::QuizQuestion> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::data_loader::quiz_models::QuizQuestion>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, Vec<u8>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, Vec<u8>)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::data_loader::search_models::SearchResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::data_loader::search_models::SearchResult>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::data_loader::verse_by_chapter::TajweedSegment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::data_loader::verse_by_chapter::TajweedSegment>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::data_loader::verse_by_chapter::Translation> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::data_loader::verse_by_chapter::Translation>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::data_loader::verse_by_chapter::Word> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::data_loader::verse_by_chapter::Word>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::data_loader::search_models::WordResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::data_loader::search_models::WordResult>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::data_loader::valid_matching_ayah::MatchedAyah {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.matched_ayah_key, serializer);
        <u32>::sse_encode(self.matched_words_count, serializer);
        <u32>::sse_encode(self.coverage, serializer);
        <u32>::sse_encode(self.score, serializer);
        <Vec<Vec<u32>>>::sse_encode(self.match_words, serializer);
    }
}

impl SseEncode for crate::data_loader::mushaf_page_info::MushafPageInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.surah_name_arabic, serializer);
        <u32>::sse_encode(self.juz_number, serializer);
        <u32>::sse_encode(self.page_number, serializer);
        <String>::sse_encode(self.next_page_route_text, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::data_loader::chapters::Chapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::data_loader::chapters::Chapter>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::data_loader::juzs::Juz> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::data_loader::juzs::Juz>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::data_loader::quiz_models::QuizGenerationError> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::data_loader::quiz_models::QuizGenerationError>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::data_loader::quiz_models::QuizQuestion> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::data_loader::quiz_models::QuizQuestion>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::data_loader::verse_by_chapter::Translation> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::data_loader::verse_by_chapter::Translation>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::data_loader::verse_by_chapter::Verse> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::data_loader::verse_by_chapter::Verse>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::data_loader::verse_by_chapter::VerseDetailWithWords> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::data_loader::verse_by_chapter::VerseDetailWithWords>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<String>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::GlyphPosition>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::GlyphPosition>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<u32>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<u32>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<u8>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::data_loader::quiz_models::QuizFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::data_loader::quiz_models::QuizScope>::sse_encode(self.scope, serializer);
        <u32>::sse_encode(self.quiz_count, serializer);
    }
}

impl SseEncode for crate::data_loader::quiz_models::QuizGenerationError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::data_loader::quiz_models::QuizGenerationError::InternalError(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::data_loader::quiz_models::QuizGenerationError::NoVersesInScope => {
                <i32>::sse_encode(1, serializer);
            }
            crate::data_loader::quiz_models::QuizGenerationError::NoValidQuestionFound => {
                <i32>::sse_encode(2, serializer);
            }
            crate::data_loader::quiz_models::QuizGenerationError::MissingAyahText => {
                <i32>::sse_encode(3, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::data_loader::quiz_models::QuizGenerationResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::data_loader::quiz_models::QuizQuestion>>::sse_encode(
            self.question,
            serializer,
        );
        <Option<crate::data_loader::quiz_models::QuizGenerationError>>::sse_encode(
            self.error, serializer,
        );
    }
}

impl SseEncode for crate::data_loader::quiz_models::QuizOption {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.text, serializer);
        <bool>::sse_encode(self.is_correct, serializer);
    }
}

impl SseEncode for crate::data_loader::quiz_models::QuizQuestion {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.verse_key, serializer);
        <String>::sse_encode(self.question_text_part1, serializer);
        <String>::sse_encode(self.question_text_part2, serializer);
        <String>::sse_encode(self.missing_part_text, serializer);
        <Vec<crate::data_loader::quiz_models::QuizOption>>::sse_encode(self.options, serializer);
        <u32>::sse_encode(self.correct_answer_index, serializer);
        <Option<Vec<u32>>>::sse_encode(self.correct_order_indices, serializer);
        <String>::sse_encode(self.quiz_type, serializer);
        <Option<Vec<String>>>::sse_encode(self.shuffled_parts, serializer);
        <Option<Vec<String>>>::sse_encode(self.shuffled_keys, serializer);
        <Option<Vec<String>>>::sse_encode(self.correct_order_keys, serializer);
    }
}

impl SseEncode for crate::data_loader::quiz_models::QuizQuestions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::data_loader::quiz_models::QuizQuestion>>::sse_encode(
            self.questions,
            serializer,
        );
    }
}

impl SseEncode for crate::data_loader::quiz_models::QuizScope {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::data_loader::quiz_models::QuizScope::All => {
                <i32>::sse_encode(0, serializer);
            }
            crate::data_loader::quiz_models::QuizScope::ByJuz { juz_numbers } => {
                <i32>::sse_encode(1, serializer);
                <Vec<u32>>::sse_encode(juz_numbers, serializer);
            }
            crate::data_loader::quiz_models::QuizScope::BySurah { surah_id } => {
                <i32>::sse_encode(2, serializer);
                <u32>::sse_encode(surah_id, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for (String, Vec<u8>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <Vec<u8>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::data_loader::search_models::SearchResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.verse_key, serializer);
        <f32>::sse_encode(self.score, serializer);
        <Vec<crate::data_loader::search_models::WordResult>>::sse_encode(self.words, serializer);
    }
}

impl SseEncode for crate::data_loader::verse_by_chapter::TajweedSegment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.rule, serializer);
        <String>::sse_encode(self.text, serializer);
    }
}

impl SseEncode for crate::data_loader::chapters::TranslatedName {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.language_name, serializer);
        <String>::sse_encode(self.name, serializer);
    }
}

impl SseEncode for crate::data_loader::verse_by_chapter::Translation {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.text, serializer);
        <std::collections::HashMap<String, String>>::sse_encode(self.footnotes, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::data_loader::verse_by_chapter::Verse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.verse_number, serializer);
        <String>::sse_encode(self.verse_key, serializer);
        <u32>::sse_encode(self.hizb_number, serializer);
        <u32>::sse_encode(self.rub_el_hizb_number, serializer);
        <u32>::sse_encode(self.ruku_number, serializer);
        <u32>::sse_encode(self.manzil_number, serializer);
        <Option<u32>>::sse_encode(self.sajdah_number, serializer);
        <u32>::sse_encode(self.page_number, serializer);
        <u32>::sse_encode(self.juz_number, serializer);
        <Vec<String>>::sse_encode(self.word_ids, serializer);
        <Vec<crate::data_loader::verse_by_chapter::Translation>>::sse_encode(
            self.translations,
            serializer,
        );
    }
}

impl SseEncode for crate::data_loader::verse_by_chapter::VerseDetailWithWords {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::data_loader::verse_by_chapter::Verse>::sse_encode(self.verse, serializer);
        <Vec<crate::data_loader::verse_by_chapter::Word>>::sse_encode(self.words, serializer);
    }
}

impl SseEncode for crate::data_loader::verse_by_chapter::Word {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.word_key, serializer);
        <u32>::sse_encode(self.position, serializer);
        <String>::sse_encode(self.char_type_name, serializer);
        <String>::sse_encode(self.text_uthmani, serializer);
        <String>::sse_encode(self.text_uthmani_simple, serializer);
        <Vec<crate::data_loader::verse_by_chapter::TajweedSegment>>::sse_encode(
            self.text_tajweed,
            serializer,
        );
        <u32>::sse_encode(self.page_number, serializer);
        <u32>::sse_encode(self.line_number, serializer);
        <u32>::sse_encode(self.chapter_id, serializer);
        <u32>::sse_encode(self.verse_id, serializer);
    }
}

impl SseEncode for crate::data_loader::search_models::WordResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.position, serializer);
        <String>::sse_encode(self.text_uthmani, serializer);
        <bool>::sse_encode(self.highlighted, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
